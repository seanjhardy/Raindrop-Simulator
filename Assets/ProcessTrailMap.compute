// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Update
#pragma kernel DrawBlack
#pragma kernel AddRain
#pragma kernel Draw
#pragma kernel ResetMap

struct Raindrop {
    float2 pos;
    float2 vel;
    float mass;
};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<Raindrop> rain;
RWTexture2D<float4> dataMap;
RWTexture2D<float4> nextDataMap;
RWTexture2D<float4> viewMap;
RWTexture2D<float4> noiseMap;

int numDrops;
int width;
int height;
int step;

static const float PI = 3.14159265f;
static const float g = 0.00098f;

float random(float2 st) {
    return frac(sin(dot(st.xy, float2(12.9898, 78.233))) * 43758.5453123);
}

float sigmoid(float x) {
    return 1.0 / (1 + exp(-x));
}


//Add the velocity to the drop at index (x,y)
void addVel(int x, int y, float2 vel) {
    float4 drop = nextDataMap[int2(x, y)];
    nextDataMap[int2(x, y)] = float4(drop.x + vel.x, drop.y + vel.y, drop.z, 0.0);
}

//Add mass to the drop at index (x, y)
void addMass(int x, int y, float mass) {
    float4 drop = nextDataMap[int2(x, y)];
    nextDataMap[int2(x, y)] = float4(drop.x, drop.y, drop.z + mass, 0.0);
}

[numthreads(8, 8, 1)]
void DrawBlack(uint3 id : SV_DispatchThreadID) {
    viewMap[id.xy] = float4(0, 0, 0, 1.0);
}

[numthreads(1, 1, 1)]
void AddRain(uint3 id : SV_DispatchThreadID) {
    Raindrop drop = rain[id.x];

    dataMap[drop.pos] = float4(drop.vel.x, drop.vel.y, drop.mass, 0.0);
}


[numthreads(16, 16, 1)]
void Update(uint3 id  : SV_DispatchThreadID) {
    if (id.x < 0 || id.x >= width || id.y < 0 || id.y >= height) return;

    float4 drop = dataMap[id.xy];
    float m = drop.z; //mass of drop

    if (m == 0) return;

    float2 vel = float2(drop.x, drop.y); //momentum of drop

    float2 gravity = float2(0, m * g); //gravity

    float mu = noiseMap[id.xy]; //coefficient of friction
    float2 friction = float2(-vel.x * mu * m, -vel.y * mu * m);

    float2 newDir = vel + gravity;

    float speed = sqrt(pow(newDir.x, 2) + pow(newDir.y, 2));

    if (step % speed != 0) {
        addMass(id.x, id.y, m);
        return;
    }

    if (m <= 0.1) {
        newDir = float2(0, 0);
        speed = 0;
    }

    float angle = atan2(newDir.y, newDir.x);
    float massLeft = random(mu*speed)*0.1;
    float massChange = m - massLeft;


    //find node to move to
    float maxScore = 0;
    float maxI = 0;
    for (int i = -1; i < 2; i++) {
        if (id.x + i >= 0 && id.x + i < width && id.y > 0) {
            //Bias score by least resistive path
            float score = noiseMap[int2(id.x + i, id.y - 1)].x;

            //Bias towards path with water
            score += nextDataMap[int2(id.x + maxI, id.y - 1)].z * 10;

            //Choose routes in line with momentum
            score -= abs(angle - atan2(1, i)) * 0.1;

            if (score >= maxScore) {
                maxScore = score;
                maxI = i;
            }
        }
    }

    m *= 0.98;

    if (m <= 0.01) {
        m = 0;
    }

    if (speed == 0.0) {
        addMass(id.x, id.y, m);
    } else {
        //set nextDataMap
        if (id.x + maxI >= 0 && id.x + maxI < width && id.y > 0) {
            addMass(id.x, id.y, massLeft);
            addMass(id.x + maxI, id.y - 1, m);
            addVel(id.x + maxI, id.y - 1, float2(0.001, maxI));
        }
    }
}

[numthreads(16, 16, 1)]
void Draw(uint3 id  : SV_DispatchThreadID) {
    if (id.x < 0 || id.x >= width || id.y < 0 || id.y >= height) {
        return;
    }

    float a = nextDataMap[id.xy].z;
    /*float lastA = viewMap[id.xy].z;
    if (lastA != 0 && a != lastA) {
        float t = 0.2;
        a = (a * t + lastA * (1 - t));
    }*/
    viewMap[id.xy] = float4(a, a, a, 1.0);
}

[numthreads(16, 16, 1)]
void ResetMap(uint3 id  : SV_DispatchThreadID) {
    if (id.x < 0 || id.x >= width || id.y < 0 || id.y >= height) {
        return;
    }

    dataMap[id.xy] = float4(0, 0, 0, 0);
}